# zf-state-machine

Этот модуль позволяет организовать в вашем приложении 
стейт-машины ([недетерминированные конечные автоматы - НКА](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BD%D0%B5%D1%87%D0%BD%D1%8B%D0%B9_%D0%B0%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82#%D0%94%D0%B5%D1%82%D0%B5%D1%80%D0%BC%D0%B8%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D1%8C)
), которые позволят выполнять дополнительные действия при переходе объектов 
из одного состояния в другое или сразу после перехода.

Особенностями данного НКА является:
-----------------------------------
1. использование [Doctrine2](http://doctrine2.readthedocs.io/en/stable/tutorials/getting-started.html) для описания списка состояний, действий и переходов
1. Использование стандартных валидаторов ZF для проверки возможности действий
1. Использование [функциональных объектов](https://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82) 
(функторов) для выполнения дополнительных действий при выполнении действия над объектом
 или после него.
1. защита от зацикливания при каскадном вызове НКА

## Оглавление
1. Область применения
1. Принцип работы
1. Пример реализации и использования:
    1. Создаем классы таблиц
    1. Описываем конфигурацию.
    1. Создаем валидаторы и функторы
    1. Используем
1. Внутренняя организация
    1. Основные методы
    1. Матрица переходов
    1. Валидаторы действия
    1. Функторы
    1. Транзакции, flush() и etc
    1. Каскадные вызовы и защита от зацикливания

## Область применения
В приложениях часто необходимо ограничить доступ к тем или иным действиям
над объектом. Управление правами на действие успешно реализуется с
помощью [RBAC](https://ru.wikipedia.org/wiki/%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF%D0%BE%D0%BC_%D0%BD%D0%B0_%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%B5_%D1%80%D0%BE%D0%BB%D0%B5%D0%B9)
-модулей. Однако RBAC-модуль контролирует право на действие 
пользователя в зависимости от роли, но не контролирует возможность совершения
действия в зависимости от состояния объекта. 
Пример: ведение пропусков. Вася может редактировать пропуск, но до тех пор, пока
пропуск не выдан.
Данная зачача успешно решается при помощи конечного автомата ([finite-state machine](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BD%D0%B5%D1%87%D0%BD%D1%8B%D0%B9_%D0%B0%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82#%D0%94%D0%B5%D1%82%D0%B5%D1%80%D0%BC%D0%B8%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D1%8C)).

## Принцип работы:

Объект - это доктриновская "сущность"(entity), которая имеет 
свойство, хранящее состояние объекта (обычно это связь много к одному к словарю
состояний).

Словарь действий - это доктриновская "сущность" - словарь возможных действий
над нашим объектом.

Матрица переходов - это две сущности A и B, связанные между собой отношением
один ко многим.
   
Для объекта, который имеет словарь состояний, описывается словарь действий 
и матрица переходов из состояния в состояние при выполнении действия. Т.к. у нас
недетерминированный конечный автомат (НКА), то выполнение действия может приводить объект
из исходного состояние в одно из нескольких других состояний согласно
матрице переходов, в том числе оставлять в исходном.

В метод НКА doAction подается объект, действие, которое хотим совершить над
объектом и дополнительные данные.  
1. НКА проверяет возможность совершения действия:
    1. наличие действия для объекта
    1. возможность выполнения действия над объектом в текущем состоянии согласно матрицы
     переходов
    1. дополнительные проверки,например в частности права на действие
1. при успешной проверке
    1. определяется новое состояние, в которое будет переведен объект
    1. выполняются, если определены, действия перед переходом в новое состояние
    1. объект переводится в новое состояние
    1. выполняются, если определены, действия после перехода объекта в новое состояние.

## Пример реализации и использования
Рассмотрим использование НКА на примере пропуска на транспортное стредство.
Пропуск имеет два состояния:
1. черновик (draft)
1. выдан (active)
В состоянии черновик его можно:
 1. смотреть (view)
 1. редактировать (edit)
 1. выдать (issue)
В состоянии active можно только смотреть (view).  
#### Создаем классы таблиц
1. [Словарь состояний пропуска](example/Entity/PassTicketCar.php)
1. [Пропуск](example/Entity/)
1. [Словарь действий (или переходов)](example/Entity/PassTicketAction.php)
1. [Таблица переходов A](example/Entity/TransitionATicketCar.php)
1. [Таблица переходов B](example/Entity/TransitionBTicketCar.php)
Загружаем данные в словари состояний, действий, и таблицы переходов:
1. [pass_ticket_status.sql](example/Sql/pass_ticket_status.sql)
1. [pass_ticket_action.sql](example/Sql/pass_ticket_action.sql)
1. [tr_a_ticket_car.sql](example/Sql/tr_a_ticket_car.sql)
1. [tr_b_ticket_car.sql](example/Sql/tr_b_ticket_car.sql)

В таблице pass_ticket_car создаем запись - пропуск, в поле pass_ticket_status_id записываем 'draft'
Рассмотрим таблицы переходов A(tr_a_ticket_car) и B(tr_b_ticket_car)
В таблице A имеем:
1. `src_id` - идентификатор исходного состояния объекта (внешний ключ к словарю состояний пропуска),
1. `action_id`- идентификатор дейсвия над объектом (внешний ключ к словарю действий),
1. `condition` - алиас валидатора, который будет проверять возможность совершения действия
Я предпочитаю использовать валидаторы-наследники \Zend\Validator\ValidatorChain, это
позволяет описать множество проверок, объединенных логическим AND, легко расширяемо при необходимости
добавить еще одну проверку.

В таблице B имеем связанные с записью из таблицы А одну или несколько записей содержащих:
1. `transition_a_id` - идентификатор связи с записью из таблицы А,
1. `dst_id` - идентификатор нового состояния объекта (внешний ключ к словарю состояний пропуска),
1. `weight` - вес перехода (объяснение ниже),
1. `condition` - условие выбора данного перехода - алиас валидатора или null,
1. `pre_functor` - алиас функтора, который будет выполнен перед сменой состояния объекта,
1. `post_functor` - алиас функтора, который будет выполнен после смены состояния объекта.

Если действие может привести только к одному новому состоянию, тогда weight не важен, а condition оставляем null.
Если же нужно, чтобы одно действие могло приводить к одному из списка состояний, тогда в таблице В будет несколько
записей связанных с одной из таблицы А, при этом задаются weight, и condition (алиас валидатора проверки постусловия). 
Записи будут проверяться в порядке уменьшения веса, первая же запись, у которой проверка постусловия будет успешной.
Если поле `condition` is null - считается, что проверка успешна. Размещайте ее с наименьшим весом.

#### Описываем конфигурацию.
конфигурацию валидаторов и функторов включим в module.config.php. Предлагаю конфигурацию валидаторов
и функторов держать в отдельных файлах и включать их в module.config.php. 
Например:
```php
$validator = include(__DIR__ . '/validators.config.php');
$smConfig = include(__DIR__ . '/state_machine.config.php');

return array_merge(
    $validator,
    $smConfig,
    [
    .....
```
Алиасы на валидаторы
```php
use Test\Validator as ValidatorNS;
use Test\StateMachine\TicketCar\Validator as SM_TCValidatorNS;

return [
    'validators' => [
        'aliases' => [
            //=============== TicketCar===========================
            'SM_TC_Draft_view' => SM_TCValidatorNS\ViewChain::class,
            'SM_TC_Draft_edit' => SM_TCValidatorNS\EditChain::class,
            'SM_TC_Draft_issue' => SM_TCValidatorNS\EditChain::class,

            'SM_TC_Active_view' => SM_TCValidatorNS\ViewChain::class,
        ],
```
Валидаторы будут найдены и созданы обычным путем с помощью валидатор-менеджера.

Функторы:
```php
use Test\StateMachine\Functor as RootFunctorNS;
use Test\StateMachine\TicketCar\Functor as TCFunctorNS;

return [
    KotaShade\StateMachine\Functor\FunctorProviderInterface::CONFIG_KEY => [
        'aliases' => [
            //================== PassTicketCar ================
            'SMF_TC_Draft_edit' => TCFunctorNS\Edit::class,
            'SMF_TC_Draft_issue' => TCFunctorNS\Issue::class,
        ],
        'abstract_factories' => [
        ],
        'factories' => [
            RootFunctorNS\EmptyFunctor::class => RootFunctorNS\EmptyFunctorFactory::class,
            TCFunctorNS\Edit::class => RootFunctorNS\BaseFunctorFactory::class,
            TCFunctorNS\Issue::class => RootFunctorNS\BaseFunctorFactory::class,
        ],
        'invokables' => [

        ],
    ]
];
```
Функторы будут найдены и созданы с помощью FunctorPluginManager, по аналогии с сервисами.

#### Создаем валидаторы и функторы

#### Используем
## Внутренняя организация
#### Основные методы
#### Матрица переходов
#### Валидаторы действия
#### Функторы
#### Транзакции, flush() и etc
#### Каскадные вызовы и защита от зацикливания
